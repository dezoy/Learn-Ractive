<h2>Modifying lists</h2>

<p>Let's say you wanted to add an item to your list. You could use <code>view.set()</code> the way you're used to, but you have to find the length of the existing array first:</p>

<pre class='prettyprint lang-js'>
var index = view.get( 'superheroes' ).length;
view.set( 'superheroes[' + length + ']', newSuperhero );
</pre>

<p>That's not ideal. We could use <code>view.update( 'superheroes' )</code> instead, which will make sure that the view is up to date:</p>

<pre class='prettyprint lang-js'>
xmen[ xmen.length ] = newSuperhero;
view.update( 'superheroes' );
</pre>

<div class='hint'>
	<p>The same applies to objects &ndash; if you change an object's properties without doing <code>view.set()</code>, things will get out of sync, and you will need to do <code>view.update( keypath )</code>.</p>

	<p>If you don't pass a keypath argument to <code>view.update()</code>, <span class='logo'>Ractive.js</span> will update everything that has changed since the last set or update.</p>
</div>

<p>But there's a more convenient way. <span class='logo'>Ractive.js</span> wraps the <em>mutator methods</em> of arrays (<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code> and <code>reverse</code>) so that they trigger view updates automatically:</p>

<pre class='prettyprint lang-js'>
xmen.push( newSuperhero );
</pre>

<p>Try running this code in the console &ndash; we've already defined our new superhero.</p>

<div class='hint'>
	<p>If you'd rather <span class='logo'>Ractive.js</span> didn't modify arrays like this, you can disable the behaviour by passing in <code>modifyArrays: false</code> at initialisation. But don't worry &ndash; we're not touching the Array prototype.</p>
</div>